break
p2 <- try(fixptfn(p1, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p2, "try-error") | any(is.nan(unlist(p2))))
stop("Error in function evaluation")
q2 <- p2 - p1
sq2 <- sqrt(crossprod(q2))
if (sq2 < tol)
break
v <- q2 - u
m.u <- append(m.u, u, after=0)
m.v <- append(m.v, v, after=0)
print()
gamma_t <- as.numeric(crossprod(u, v))/as.numeric(crossprod(v, v))
q <- u
alpha <- rep(0, min(m, iter - 1))
if (iter >= 2) {
for (i in 1:min(m, (iter - 1))) {
rho <- 1/as.numeric(crossprod(m.v[[i]], m.v[[i]]))
alpha[i] <- rho * crossprod(m.v[[i]], q)
q <- q - alpha[i] * m.v[[i]]
}
}
r <- gamma_t * q
if (iter >= 2) {
for (i in 1:min(m, iter - 1)) {
r <- r + alpha[i] * m.u[[i]]
}
}
p.new <- p.now - r
if (inherits(p.new, "try-error") | any(is.nan(p.new))) {
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
else {
if (is.finite(objfn.inc)) {
lnew <- try(objfn(p.new, ...), silent = TRUE)
leval <- leval + 1
}
else lnew <- lold
if (inherits(lnew, "try-error") | is.nan(lnew) |
(lnew > lold + objfn.inc)) {
if (verbose)
print(paste("Fallback by:", lnew - lold))
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
}
if (obj.stop)
if (abs(lnew - lold) < obj.tol)
break
p.now <- p.new
if (!is.nan(lnew))
lold <- lnew
if (verbose)
cat("Objective fn: ", lnew, "  Extrapolation: ",
extrap, "\n")
if (intermed)
p.inter <- rbind(p.inter, c(p.now, lnew))
if (iter >= m){
m.u <- m.u[[-m]]
m.v <- m.v[[-m]]
}
iter <- iter + 1
}
if (feval >= maxiter)
conv <- FALSE
if (is.infinite(objfn.inc)) {
lold <- objfn(p.now, ...)
leval <- leval + 1
}
rownames(p.inter) <- NULL
if (!intermed)
return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv))
else return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv,
p.inter = p.inter))
}
fp <- LBQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(tol = tol, maxiter = 1e5, m = min(10,dim)))
LBQN <- function (par, fixptfn, objfn, A=A, b=b, L=L, control = list())
{
control.default <- list(m = 10, objfn.inc = 1, tol = 1e-07,
obj.tol = 1e-07, maxiter = 1500, verbose = FALSE, obj.stop = FALSE,
intermed = FALSE)
namc <- names(control)
if (!all(namc %in% names(control.default)))
stop("unknown names in control: ", namc[!(namc %in% names(control.default))])
ctrl <- modifyList(control.default, control)
m <- ctrl$m
maxiter <- ctrl$maxiter
tol <- ctrl$tol
objfn.inc <- ctrl$objfn.inc
verbose <- ctrl$verbose
intermed <- ctrl$intermed
obj.tol <- ctrl$obj.tol
obj.stop <- ctrl$obj.stop
if (verbose)
cat("LBQN \n")
if (missing(objfn))
stop("\n objective function is not available \n\n")
if (missing(par))
stop("\n Starting vector not available \n")
P <- length(par)
iter <- 1
p.now <- par
m.u <- list()
m.v <- list()
lold <- objfn(p.now, ...)
leval <- 1
if (verbose)
cat("Objective fn: ", lold, "\n")
feval <- 0
conv <- TRUE
p.inter <- c(p.now, lold)
while (iter < maxiter) {
extrap <- TRUE
p1 <- try(fixptfn(p.now, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p1, "try-error") | any(is.nan(unlist(p1))))
stop("Error in function evaluation")
u <- p1 - p.now
sr2 <- crossprod(u)
if (sqrt(sr2) < tol)
break
p2 <- try(fixptfn(p1, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p2, "try-error") | any(is.nan(unlist(p2))))
stop("Error in function evaluation")
q2 <- p2 - p1
sq2 <- sqrt(crossprod(q2))
if (sq2 < tol)
break
v <- q2 - u
m.u <- append(m.u, u, after=0)
m.v <- append(m.v, v, after=0)
print()
gamma_t <- as.numeric(crossprod(u, v))/as.numeric(crossprod(v, v))
q <- u
alpha <- rep(0, min(m, iter - 1))
if (iter >= 2) {
for (i in 1:min(m, (iter - 1))) {
rho <- 1/as.numeric(crossprod(m.v[[i]], m.v[[i]]))
alpha[i] <- rho * crossprod(m.v[[i]], q)
q <- q - alpha[i] * m.v[[i]]
}
}
r <- gamma_t * q
if (iter >= 2) {
for (i in 1:min(m, iter - 1)) {
r <- r + alpha[i] * m.u[[i]]
}
}
p.new <- p.now - r
if (inherits(p.new, "try-error") | any(is.nan(p.new))) {
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
else {
if (is.finite(objfn.inc)) {
lnew <- try(objfn(p.new, ...), silent = TRUE)
leval <- leval + 1
}
else lnew <- lold
if (inherits(lnew, "try-error") | is.nan(lnew) |
(lnew > lold + objfn.inc)) {
if (verbose)
print(paste("Fallback by:", lnew - lold))
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
}
if (obj.stop)
if (abs(lnew - lold) < obj.tol)
break
p.now <- p.new
if (!is.nan(lnew))
lold <- lnew
if (verbose)
cat("Objective fn: ", lnew, "  Extrapolation: ",
extrap, "\n")
if (intermed)
p.inter <- rbind(p.inter, c(p.now, lnew))
if (iter >= m){
m.u <- m.u[[-m]]
m.v <- m.v[[-m]]
}
iter <- iter + 1
}
if (feval >= maxiter)
conv <- FALSE
if (is.infinite(objfn.inc)) {
lold <- objfn(p.now, ...)
leval <- leval + 1
}
rownames(p.inter) <- NULL
if (!intermed)
return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv))
else return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv,
p.inter = p.inter))
}
fp <- LBQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(tol = tol, maxiter = 1e5, m = min(10,dim)))
time_bqn2 <- rep(0, N)
obj_bqn2 <- rep(0, N)
eval_bqn2 <- rep(0, N)
for (i in 1:N)
{
print(i)
start <- truth + as.matrix(start.all[i,])
start.time <- Sys.time()
fp <- BQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(qn=min(dim,10), tol=tol, maxiter=1e5))
end.time <- Sys.time()
time_bqn2[i] <- end.time - start.time
obj_bqn2[i] <- fp$value.objfn
eval_bqn2[i] <- fp$fpevals
}
print(round(quantile(time_bqn2, c(.5, .25, .75)), 3))
print(quantile(eval_bqn2, c(.5, .25, .75)))
print(round(quantile(obj_bqn2, c(.5, .25, .75)), 4))
time_bqn1 <- rep(0, N)
obj_bqn1 <- rep(0, N)
eval_bqn1 <- rep(0, N)
for (i in 1:N)
{
print(i)
start <- truth + as.matrix(start.all[i,])
start.time <- Sys.time()
fp <- BQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(qn=1, tol=tol, maxiter=1e5))
end.time <- Sys.time()
time_bqn1[i] <- end.time - start.time
obj_bqn1[i] <- fp$value.objfn
eval_bqn1[i] <- fp$fpevals
}
print(round(quantile(time_bqn1, c(.5, .25, .75)), digits=2))
print(quantile(eval_bqn1, c(.5, .25, .75)))
print(round(quantile(obj_bqn1, c(.5, .25, .75)), 4))
LBQN <- function (par, fixptfn, objfn,..., control = list())
{
control.default <- list(m = 10, objfn.inc = 1, tol = 1e-07,
obj.tol = 1e-07, maxiter = 1500, verbose = FALSE, obj.stop = FALSE,
intermed = FALSE)
namc <- names(control)
if (!all(namc %in% names(control.default)))
stop("unknown names in control: ", namc[!(namc %in% names(control.default))])
ctrl <- modifyList(control.default, control)
m <- ctrl$m
maxiter <- ctrl$maxiter
tol <- ctrl$tol
objfn.inc <- ctrl$objfn.inc
verbose <- ctrl$verbose
intermed <- ctrl$intermed
obj.tol <- ctrl$obj.tol
obj.stop <- ctrl$obj.stop
if (verbose)
cat("LBQN \n")
if (missing(objfn))
stop("\n objective function is not available \n\n")
if (missing(par))
stop("\n Starting vector not available \n")
P <- length(par)
iter <- 1
p.now <- par
m.u <- list()
m.v <- list()
lold <- objfn(p.now, ...)
leval <- 1
if (verbose)
cat("Objective fn: ", lold, "\n")
feval <- 0
conv <- TRUE
p.inter <- c(p.now, lold)
while (iter < maxiter) {
extrap <- TRUE
p1 <- try(fixptfn(p.now, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p1, "try-error") | any(is.nan(unlist(p1))))
stop("Error in function evaluation")
u <- p1 - p.now
sr2 <- crossprod(u)
if (sqrt(sr2) < tol)
break
p2 <- try(fixptfn(p1, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p2, "try-error") | any(is.nan(unlist(p2))))
stop("Error in function evaluation")
q2 <- p2 - p1
sq2 <- sqrt(crossprod(q2))
if (sq2 < tol)
break
v <- q2 - u
m.u <- append(m.u, u, after=0)
m.v <- append(m.v, v, after=0)
print()
gamma_t <- as.numeric(crossprod(u, v))/as.numeric(crossprod(v, v))
q <- u
alpha <- rep(0, min(m, iter - 1))
if (iter >= 2) {
for (i in 1:min(m, (iter - 1))) {
rho <- 1/as.numeric(crossprod(m.v[[i]], m.v[[i]]))
alpha[i] <- rho * crossprod(m.v[[i]], q)
q <- q - alpha[i] * m.v[[i]]
}
}
r <- gamma_t * q
if (iter >= 2) {
for (i in 1:min(m, iter - 1)) {
r <- r + alpha[i] * m.u[[i]]
}
}
p.new <- p.now - r
if (inherits(p.new, "try-error") | any(is.nan(p.new))) {
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
else {
if (is.finite(objfn.inc)) {
lnew <- try(objfn(p.new, ...), silent = TRUE)
leval <- leval + 1
}
else lnew <- lold
if (inherits(lnew, "try-error") | is.nan(lnew) |
(lnew > lold + objfn.inc)) {
if (verbose)
print(paste("Fallback by:", lnew - lold))
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
}
if (obj.stop)
if (abs(lnew - lold) < obj.tol)
break
p.now <- p.new
if (!is.nan(lnew))
lold <- lnew
if (verbose)
cat("Objective fn: ", lnew, "  Extrapolation: ",
extrap, "\n")
if (intermed)
p.inter <- rbind(p.inter, c(p.now, lnew))
if (iter >= m){
m.u <- m.u[[-m]]
m.v <- m.v[[-m]]
}
iter <- iter + 1
}
if (feval >= maxiter)
conv <- FALSE
if (is.infinite(objfn.inc)) {
lold <- objfn(p.now, ...)
leval <- leval + 1
}
rownames(p.inter) <- NULL
if (!intermed)
return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv))
else return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv,
p.inter = p.inter))
}
fp <- LBQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(tol = tol, maxiter = 1e5, m = min(10,dim)))
library(quasiNewtonMM)
LBQN
LBQN <- function (par, fixptfn, objfn,..., control = list())
{
control.default <- list(m = 10, objfn.inc = 1, tol = 1e-07,
obj.tol = 1e-07, maxiter = 1500, verbose = FALSE, obj.stop = FALSE,
intermed = FALSE)
namc <- names(control)
if (!all(namc %in% names(control.default)))
stop("unknown names in control: ", namc[!(namc %in% names(control.default))])
ctrl <- modifyList(control.default, control)
m <- ctrl$m
maxiter <- ctrl$maxiter
tol <- ctrl$tol
objfn.inc <- ctrl$objfn.inc
verbose <- ctrl$verbose
intermed <- ctrl$intermed
obj.tol <- ctrl$obj.tol
obj.stop <- ctrl$obj.stop
if (verbose)
cat("LBQN \n")
if (missing(objfn))
stop("\n objective function is not available \n\n")
if (missing(par))
stop("\n Starting vector not available \n")
P <- length(par)
iter <- 1
p.now <- par
m.u <- list()
m.v <- list()
lold <- objfn(p.now, ...)
leval <- 1
if (verbose)
cat("Objective fn: ", lold, "\n")
feval <- 0
conv <- TRUE
p.inter <- c(p.now, lold)
while (iter < maxiter) {
extrap <- TRUE
p1 <- try(fixptfn(p.now, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p1, "try-error") | any(is.nan(unlist(p1))))
stop("Error in function evaluation")
u <- p1 - p.now
sr2 <- crossprod(u)
if (sqrt(sr2) < tol)
break
p2 <- try(fixptfn(p1, ...), silent = TRUE)
feval <- feval + 1
if (inherits(p2, "try-error") | any(is.nan(unlist(p2))))
stop("Error in function evaluation")
q2 <- p2 - p1
sq2 <- sqrt(crossprod(q2))
if (sq2 < tol)
break
v <- q2 - u
m.u <- append(m.u, u, after=0)
m.v <- append(m.v, v, after=0)
print()
gamma_t <- as.numeric(crossprod(u, v))/as.numeric(crossprod(v, v))
q <- u
alpha <- rep(0, min(m, iter - 1))
if (iter >= 2) {
for (i in 1:min(m, (iter - 1))) {
rho <- 1/as.numeric(crossprod(m.v[[i]], m.v[[i]]))
alpha[i] <- rho * crossprod(m.v[[i]], q)
q <- q - alpha[i] * m.v[[i]]
}
}
r <- gamma_t * q
if (iter >= 2) {
for (i in 1:min(m, iter - 1)) {
r <- r + alpha[i] * m.u[[i]]
}
}
p.new <- p.now - r
if (inherits(p.new, "try-error") | any(is.nan(p.new))) {
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
else {
if (is.finite(objfn.inc)) {
lnew <- try(objfn(p.new, ...), silent = TRUE)
leval <- leval + 1
}
else lnew <- lold
if (inherits(lnew, "try-error") | is.nan(lnew) |
(lnew > lold + objfn.inc)) {
if (verbose)
print(paste("Fallback by:", lnew - lold))
p.new <- p2
lnew <- try(objfn(p2, ...), silent = TRUE)
leval <- leval + 1
extrap <- FALSE
}
}
if (obj.stop)
if (abs(lnew - lold) < obj.tol)
break
p.now <- p.new
if (!is.nan(lnew))
lold <- lnew
if (verbose)
cat("Objective fn: ", lnew, "  Extrapolation: ",
extrap, "\n")
if (intermed)
p.inter <- rbind(p.inter, c(p.now, lnew))
if (iter >= m){
m.u <- m.u[[-m]]
m.v <- m.v[[-m]]
}
iter <- iter + 1
}
if (feval >= maxiter)
conv <- FALSE
if (is.infinite(objfn.inc)) {
lold <- objfn(p.now, ...)
leval <- leval + 1
}
rownames(p.inter) <- NULL
if (!intermed)
return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv))
else return(list(par = p.now, value.objfn = lold, iter = iter,
fpevals = feval, objfevals = leval, convergence = conv,
p.inter = p.inter))
}
fp <- LBQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(tol = tol, maxiter = 1e5, m = min(10,dim)))
fp <- LBQN(par = start, A=A, a=a, L=L, fixptfn = update, objfn = objective,
control = list(tol = tol, maxiter = 1e5, m = min(10,dim)))
